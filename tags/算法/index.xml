<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>算法 on 望境</title>
        <link>https://w2343419-del.github.io/WangScape/tags/%E7%AE%97%E6%B3%95/</link>
        <description>Recent content in 算法 on 望境</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Sat, 28 Feb 2026 11:31:00 +0800</lastBuildDate><atom:link href="https://w2343419-del.github.io/WangScape/tags/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>P1004 [NOIP 2000 提高组] 方格取数 分析与总结</title>
        <link>https://w2343419-del.github.io/WangScape/p/p1004-noip-2000-%E6%8F%90%E9%AB%98%E7%BB%84-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0-%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/</link>
        <pubDate>Sat, 28 Feb 2026 11:31:00 +0800</pubDate>
        
        <guid>https://w2343419-del.github.io/WangScape/p/p1004-noip-2000-%E6%8F%90%E9%AB%98%E7%BB%84-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0-%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/</guid>
        <description>&lt;p&gt;这是一道经典但具有一定难度的棋盘模型题，虽然是 2000 年的 NOIP 题目，但作为压轴，对于像我这样第一次接触的人来说，还是相当困难的。&lt;/p&gt;
&lt;p&gt;先看题目背景&lt;/p&gt;
&lt;p&gt;NOIP 2000 提高组 T4&lt;/p&gt;
&lt;p&gt;题目描述
设有 N×N 的方格图 (N≤9)，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 0。&lt;/p&gt;
&lt;p&gt;某人从图的左上角的 A 点（0，0）出发，可以向下行走，也可以向右走，直到到达右下角的 B 点（N, N)。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 0）。&lt;/p&gt;
&lt;p&gt;此人从 A 点到 B 点共走两次，试找出 2 条这样的路径，使得取得的数之和为最大。&lt;/p&gt;
&lt;p&gt;输入格式
输入的第一行为一个整数 N（表示 N×N 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 0 表示输入结束。&lt;/p&gt;
&lt;p&gt;输出格式
只需输出一个整数，表示 2 条路径上取得的最大的和。&lt;/p&gt;
&lt;p&gt;输入输出样例
输入
8
2 3 13
2 6  6
3 5  7
4 4 14
5 2 21
5 6  4
6 3 15
7 2 14
0 0  0&lt;/p&gt;
&lt;p&gt;输出
67&lt;/p&gt;
&lt;p&gt;说明/提示
数据范围：1≤N≤9。&lt;/p&gt;
&lt;p&gt;我一开始尝试是选择的先进行一轮枚举，然后再对已进行了更改的 matrix 进行再一次的枚举（就是模拟取数），但是发现难度有点过大。最后实在想不出来解决方法了，找了 Claude 老师，它给出的解决方法是采用 dp 算法（详见解法一），我又想到了 DFS 结合剪枝的算法（感谢自己之前做的走迷宫问题，那是一道有关最少步数的算法题，刚好适用于 DFS 结合剪枝）（详见解法二），随后 Claude 还给出了一个适用于一般解的算法————费用流解法（难度过大，属于超纲解法，略写一二，详见解法三）。&lt;/p&gt;
&lt;p&gt;ps. 解释一下为什么不能采取两次枚举。一次路径会改变地图，影响第二次，所以两条路径必须联动考虑。&lt;/p&gt;
&lt;p&gt;解法一（dp 动态规划）：&lt;/p&gt;
&lt;p&gt;核心思想：将两条路径同步推进，用一个DP同时模拟两个人的行走。&lt;/p&gt;
&lt;p&gt;状态设计：设 dp[k][x1][x2]，其中：&lt;/p&gt;
&lt;p&gt;k 为当前走的步数（即 x + y 的值，从2到2N）
x1、x2 分别为两人当前所在的行号
由 k 和 x 可以推出 y = k - x（关键，这一步降低了维度），因此列号不需要单独存储&lt;/p&gt;
&lt;p&gt;去重处理：当两人在同一格时（x1 == x2，则 y1 == y2），该格只取一次。&lt;/p&gt;
&lt;p&gt;转移：每步两人各自可以选择向右或向下，共4种组合。&lt;/p&gt;
&lt;p&gt;完整代码```C\n//&lt;/p&gt;
&lt;p&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/p&gt;
&lt;p&gt;int N;
int map[10][10];
int dp[20][10][10]; // dp[步数][人1的行][人2的行]&lt;/p&gt;
&lt;p&gt;int main() {
scanf(&amp;quot;%d&amp;quot;, &amp;amp;N);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int x, y, v;
while (scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;x, &amp;amp;y, &amp;amp;v) &amp;amp;&amp;amp; (x || y || v))
    map[x][y] = v;

// 初始化为-1表示不可达
for (int k = 0; k &amp;lt; 20; k++)
    for (int i = 0; i &amp;lt; 10; i++)
        for (int j = 0; j &amp;lt; 10; j++)
            dp[k][i][j] = -1;

dp[2][1][1] = map[1][1];

for (int k = 2; k &amp;lt; 2 * N; k++) {
    for (int x1 = 1; x1 &amp;lt;= N; x1++) {
        int y1 = k - x1;
        if (y1 &amp;lt; 1 || y1 &amp;gt; N) continue;

        for (int x2 = x1; x2 &amp;lt;= N; x2++) {
            int y2 = k - x2;
            if (y2 &amp;lt; 1 || y2 &amp;gt; N) continue;
            if (dp[k][x1][x2] &amp;lt; 0) continue;

            for (int m1 = 0; m1 &amp;lt;= 1; m1++) {
                for (int m2 = 0; m2 &amp;lt;= 1; m2++) {
                    int nx1 = x1 + m1,     ny1 = y1 + (1 - m1);
                    int nx2 = x2 + m2,     ny2 = y2 + (1 - m2);

                    if (nx1 &amp;gt; N || ny1 &amp;gt; N) continue;
                    if (nx2 &amp;gt; N || ny2 &amp;gt; N) continue;

                    int gain = map[nx1][ny1];
                    if (nx1 != nx2) gain += map[nx2][ny2];

                    // 规范化，令 nx1 &amp;lt;= nx2
                    int a = nx1, b = nx2;
                    if (a &amp;gt; b) { int t = a; a = b; b = t; }

                    int newval = dp[k][x1][x2] + gain;
                    if (newval &amp;gt; dp[k + 1][a][b])
                        dp[k + 1][a][b] = newval;
                }
            }
        }
    }
}

printf(&amp;quot;%d\n&amp;quot;, dp[2 * N][N][N]);
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}\n\n```\n\n&lt;/p&gt;
&lt;p&gt;时间复杂度：O(N³)&lt;/p&gt;
&lt;p&gt;解法二（DFS + 剪枝）：&lt;/p&gt;
&lt;p&gt;核心思想：类似于 dp 算法（毕竟深搜和 dp 本质上就是一个东西），但添加了记忆化搜索这一步，避免了重复搜索。（若无记忆化搜索，计算量将是指数级爆炸，在 N=9 时约为 4^16 次）&lt;/p&gt;
&lt;p&gt;完整代码```C\n//&lt;/p&gt;
&lt;p&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;&lt;/p&gt;
&lt;p&gt;int N;
int map[10][10];
int memo[20][10][10]; // 记忆化数组
int visited[20][10][10]; // 标记是否计算过&lt;/p&gt;
&lt;p&gt;int dfs(int k, int x1, int x2) {
// 终点：两人都到达(N, N)
if (x1 == N &amp;amp;&amp;amp; x2 == N) return 0;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 查记忆化
if (visited[k][x1][x2]) return memo[k][x1][x2];
visited[k][x1][x2] = 1;

int y1 = k - x1;
int y2 = k - x2;
int best = -1; // -1表示无效状态

// 枚举两人各自的下一步：0=向右，1=向下
for (int m1 = 0; m1 &amp;lt;= 1; m1++) {
    for (int m2 = 0; m2 &amp;lt;= 1; m2++) {
        int nx1 = x1 + m1,  ny1 = y1 + (1 - m1);
        int nx2 = x2 + m2,  ny2 = y2 + (1 - m2);

        if (nx1 &amp;gt; N || ny1 &amp;gt; N) continue;
        if (nx2 &amp;gt; N || ny2 &amp;gt; N) continue;

        // 规范化
        int a = nx1, b = nx2;
        if (a &amp;gt; b) { int t = a; a = b; b = t; }

        int sub = dfs(k + 1, a, b);
        if (sub &amp;lt; 0) continue; // 子状态不可达

        // 当前步两人取得的值
        int gain = map[nx1][ny1];
        if (nx1 != nx2) gain += map[nx2][ny2];

        if (gain + sub &amp;gt; best) best = gain + sub;
    }
}

memo[k][x1][x2] = best;
return best;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int main() {
scanf(&amp;quot;%d&amp;quot;, &amp;amp;N);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int x, y, v;
while (scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;x, &amp;amp;y, &amp;amp;v) &amp;amp;&amp;amp; (x || y || v))
    map[x][y] = v;

memset(visited, 0, sizeof(visited));

// 两人同时从(1,1)出发，起点格只取一次
int start_val = map[1][1];
int result = dfs(2, 1, 1);

printf(&amp;quot;%d\n&amp;quot;, result &amp;gt;= 0 ? start_val + result : 0);
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}\n\n```\n\n&lt;/p&gt;
&lt;p&gt;时间复杂度：O(N³)&lt;/p&gt;
&lt;p&gt;解法三（费用流解法）：&lt;/p&gt;
&lt;p&gt;核心思想：将&amp;quot;两条路径取最大值&amp;quot;转化为网络流问题。&lt;/p&gt;
&lt;p&gt;建模思路
关键观察：
两条从 A 到 B 的路径 = 从源点到汇点流量为 2 的流
每个格子最多取一次 = 每个节点容量为 1
取得数字最大 = 费用最大（转为最小费用取负值）&lt;/p&gt;
&lt;p&gt;拆点： 每个格子 (i,j) 拆成两个节点 in 和 out：
in → out：容量 1，费用 -map[i][j]（取负是因为求最小费用）
in → out：再加一条容量 1，费用 0（允许第二条路径经过但不重复取值）
即：合并为容量 2，但只有第一单位流有收益&lt;/p&gt;
&lt;p&gt;连边： (i,j) 的 out 连向 (i+1,j) 的 in 和 (i,j+1) 的 in，容量 2，费用 0。&lt;/p&gt;
&lt;p&gt;源汇： 源点 S 连 (1,1).in，(N,N).out 连汇点 T，流量均为 2。&lt;/p&gt;
&lt;p&gt;每个格子(i,j)拆点后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    容量1，费用-val  (第一条路经过，取走数字)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;in(i,j) ===============&amp;gt; out(i,j)
容量1，费用0     (第二条路经过，数字已取走)&lt;/p&gt;
&lt;p&gt;完整代码（MCMF，SPFA实现）```C\n//&lt;/p&gt;
&lt;p&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;&lt;/p&gt;
&lt;p&gt;#define MAXN 1000
#define MAXE 10000
#define INF  0x3f3f3f3f&lt;/p&gt;
&lt;p&gt;// ========== 链式前向星 ==========
int head[MAXN], nxt[MAXE], to[MAXE], cap[MAXE], cost[MAXE], tot;&lt;/p&gt;
&lt;p&gt;void init() {
memset(head, -1, sizeof(head));
tot = 0;
}&lt;/p&gt;
&lt;p&gt;void add_edge(int u, int v, int c, int w) {
to[tot] = v; cap[tot] = c; cost[tot] = w; nxt[tot] = head[u]; head[u] = tot++;
to[tot] = u; cap[tot] = 0; cost[tot] = -w; nxt[tot] = head[v]; head[v] = tot++;
}&lt;/p&gt;
&lt;p&gt;// ========== SPFA + 增广（MCMF）==========
int dist[MAXN], in_queue[MAXN], prevv[MAXN], preve[MAXN];
int queue[MAXN * 100];&lt;/p&gt;
&lt;p&gt;int spfa(int s, int t, int n) {
memset(dist, 0x3f, sizeof(int) * (n + 1));
memset(in_queue, 0, sizeof(int) * (n + 1));
dist[s] = 0;
int front = 0, rear = 0;
queue[rear++] = s;
in_queue[s] = 1;
while (front != rear) {
int u = queue[front++];
in_queue[u] = 0;
for (int e = head[u]; e != -1; e = nxt[e]) {
if (cap[e] &amp;gt; 0 &amp;amp;&amp;amp; dist[to[e]] &amp;gt; dist[u] + cost[e]) {
dist[to[e]] = dist[u] + cost[e];
prevv[to[e]] = u;
preve[to[e]] = e;
if (!in_queue[to[e]]) {
queue[rear++] = to[e];
in_queue[to[e]] = 1;
}
}
}
}
return dist[t] &amp;lt; INF;
}&lt;/p&gt;
&lt;p&gt;int mcmf(int s, int t, int n) {
int total_cost = 0;
while (spfa(s, t, n)) {
// 找最小可增广量（这里每次增广1单位即可）
int flow = INF;
for (int v = t; v != s; v = prevv[v])
if (cap[preve[v]] &amp;lt; flow) flow = cap[preve[v]];
// 增广
for (int v = t; v != s; v = prevv[v]) {
cap[preve[v]] -= flow;
cap[preve[v] ^ 1] += flow;
}
total_cost += dist[t] * flow;
}
return total_cost;
}&lt;/p&gt;
&lt;p&gt;// ========== 建图 ==========
// 节点编号：(i,j) 的 in  = (i-1)&lt;em&gt;N+j
//           (i,j) 的 out = N&lt;/em&gt;N + (i-1)&lt;em&gt;N+j
// 源点 S = 2&lt;/em&gt;N&lt;em&gt;N+1，汇点 T = 2&lt;/em&gt;N*N+2&lt;/p&gt;
&lt;p&gt;int main() {
int N;
scanf(&amp;quot;%d&amp;quot;, &amp;amp;N);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int map[10][10] = {0};
int x, y, v;
while (scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;x, &amp;amp;y, &amp;amp;v) &amp;amp;&amp;amp; (x || y || v))
    map[x][y] = v;

init();

int S = 2 * N * N + 1;
int T = 2 * N * N + 2;
int total_nodes = T;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#define IN(i,j)  ((i-1)&lt;em&gt;N+(j))
#define OUT(i,j) (N&lt;/em&gt;N+(i-1)*N+(j))&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 拆点建边
for (int i = 1; i &amp;lt;= N; i++) {
    for (int j = 1; j &amp;lt;= N; j++) {
        if (map[i][j] &amp;gt; 0) {
            // 第一单位流：取走数字，费用为负（求最小费用）
            add_edge(IN(i,j), OUT(i,j), 1, -map[i][j]);
            // 第二单位流：不取数字
            add_edge(IN(i,j), OUT(i,j), 1, 0);
        } else {
            add_edge(IN(i,j), OUT(i,j), 2, 0);
        }
        // 向右、向下连边
        if (j + 1 &amp;lt;= N) add_edge(OUT(i,j), IN(i,j+1), 2, 0);
        if (i + 1 &amp;lt;= N) add_edge(OUT(i,j), IN(i+1,j), 2, 0);
    }
}

// 源汇
add_edge(S, IN(1,1), 2, 0);
add_edge(OUT(N,N), T, 2, 0);

int ans = -mcmf(S, T, total_nodes);
printf(&amp;quot;%d\n&amp;quot;, ans);
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}\n\n```\n\n&lt;/p&gt;
&lt;p&gt;时间复杂度：O(E · SPFA)&lt;/p&gt;
&lt;p&gt;优势：可轻松扩展到 K 条路径。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
