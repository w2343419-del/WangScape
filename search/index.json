[{"content":"这是一道经典但具有一定难度的棋盘模型题。虽然是 2000 年的 NOIP 题目，但作为压轴题，对于第一次接触的人来说还是相当困难的。本文总结了三种不同的解法：动态规划、DFS 记忆化和最小费用最大流，从易到难逐步展开。\n题目背景与描述 NOIP 2000 提高组 T4\n题目描述\n设有 N×N 的方格图 (N≤9)，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 0。 某人从图的左上角的 A 点（0，0）出发，可以向下行走，也可以向右走，直到到达右下角的 B 点（N, N)。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 0）。 此人从 A 点到 B 点共走两次，试找出 2 条这样的路径，使得取得的数之和为最大。\n输入格式\n输入的第一行为一个整数 N（表示 N×N 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 0 表示输入结束。\n输出格式\n只需输出一个整数，表示 2 条路径上取得的最大的和。\n输入输出样例\n输入\n8\n2 3 13\n2 6 6\n3 5 7\n4 4 14\n5 2 21\n5 6 4\n6 3 15\n7 2 14\n0 0 0\n输出 67\n说明/提示\n数据范围：1≤N≤9。\n我一开始尝试是选择的先进行一轮枚举，然后再对已进行了更改的 matrix 进行再一次的枚举（就是模拟取数），但是发现难度有点过大。最后实在想不出来解决方法了，找了 Claude，它给出的解决方法是采用 dp 算法（详见解法一），我又想到了 DFS 结合剪枝的算法（感谢自己之前做的走迷宫问题，那是一道有关最少步数的算法题，刚好适用于 DFS 结合剪枝）（详见解法二），随后 Claude 还给出了一个适用于一般解的算法————费用流解法（难度过大，属于超纲解法，略写一二，详见解法三）。\nps. 解释一下为什么不能采取两次枚举。一次路径会改变地图，影响第二次，所以两条路径必须联动考虑。\n解法一（dp 动态规划）：\n核心思想：将两条路径同步推进，用一个DP同时模拟两个人的行走。\n状态设计：设 dp[k][x1][x2]，其中：\nk 为当前走的步数（即 x + y 的值，从2到2N）\nx1、x2 分别为两人当前所在的行号\n由 k 和 x 可以推出 y = k - x（关键，这一步降低了维度），因此列号不需要单独存储\n去重处理：当两人在同一格时（x1 == x2，则 y1 == y2），该格只取一次。\n转移：每步两人各自可以选择向右或向下，共4种组合。\n完整代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;stdio.h\u0026gt; int N; int map[10][10]; int dp[20][10][10]; // dp[步数][人1的行][人2的行] int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); int x, y, v; while (scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;v) \u0026amp;\u0026amp; (x || y || v)) map[x][y] = v; // 初始化为-1表示不可达 for (int k = 0; k \u0026lt; 20; k++) for (int i = 0; i \u0026lt; 10; i++) for (int j = 0; j \u0026lt; 10; j++) dp[k][i][j] = -1; dp[2][1][1] = map[1][1]; // ========== 动态规划主循环 ========== for (int k = 2; k \u0026lt; 2 * N; k++) { for (int x1 = 1; x1 \u0026lt;= N; x1++) { int y1 = k - x1; if (y1 \u0026lt; 1 || y1 \u0026gt; N) continue; for (int x2 = x1; x2 \u0026lt;= N; x2++) { int y2 = k - x2; if (y2 \u0026lt; 1 || y2 \u0026gt; N) continue; if (dp[k][x1][x2] \u0026lt; 0) continue; // 尝试所有4种移动组合 for (int m1 = 0; m1 \u0026lt;= 1; m1++) { for (int m2 = 0; m2 \u0026lt;= 1; m2++) { int nx1 = x1 + m1, ny1 = y1 + (1 - m1); int nx2 = x2 + m2, ny2 = y2 + (1 - m2); if (nx1 \u0026gt; N || ny1 \u0026gt; N) continue; if (nx2 \u0026gt; N || ny2 \u0026gt; N) continue; // 计算当前步收益 int gain = map[nx1][ny1]; if (nx1 != nx2) gain += map[nx2][ny2]; // 规范化：保证 a \u0026lt;= b int a = nx1, b = nx2; if (a \u0026gt; b) { int t = a; a = b; b = t; } int newval = dp[k][x1][x2] + gain; if (newval \u0026gt; dp[k + 1][a][b]) dp[k + 1][a][b] = newval; } } } } } printf(\u0026#34;%d\\n\u0026#34;, dp[2 * N][N][N]); return 0; } 时间复杂度：O(N³)\n解法二（DFS + 剪枝）：\n核心思想：类似于 dp 算法（毕竟深搜和 dp 本质上就是一个东西），但添加了记忆化搜索这一步，避免了重复搜索。（若无记忆化搜索，计算量将是指数级爆炸，在 N=9 时约为 4^16 次）\n完整代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; // ========== DFS + 记忆化搜索 ========== int N; int map[10][10]; int memo[20][10][10]; // 记忆化数组 int visited[20][10][10]; // 标记是否计算过 int dfs(int k, int x1, int x2) { if (x1 == N \u0026amp;\u0026amp; x2 == N) return 0; if (visited[k][x1][x2]) return memo[k][x1][x2]; visited[k][x1][x2] = 1; int y1 = k - x1; int y2 = k - x2; int best = -1; for (int m1 = 0; m1 \u0026lt;= 1; m1++) { for (int m2 = 0; m2 \u0026lt;= 1; m2++) { int nx1 = x1 + m1, ny1 = y1 + (1 - m1); int nx2 = x2 + m2, ny2 = y2 + (1 - m2); if (nx1 \u0026gt; N || ny1 \u0026gt; N) continue; if (nx2 \u0026gt; N || ny2 \u0026gt; N) continue; int a = nx1, b = nx2; if (a \u0026gt; b) { int t = a; a = b; b = t; } int sub = dfs(k + 1, a, b); if (sub \u0026lt; 0) continue; int gain = map[nx1][ny1]; if (nx1 != nx2) gain += map[nx2][ny2]; if (gain + sub \u0026gt; best) best = gain + sub; } } memo[k][x1][x2] = best; return best; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); int x, y, v; while (scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;v) \u0026amp;\u0026amp; (x || y || v)) map[x][y] = v; memset(visited, 0, sizeof(visited)); int start_val = map[1][1]; int result = dfs(2, 1, 1); printf(\u0026#34;%d\\n\u0026#34;, result \u0026gt;= 0 ? start_val + result : 0); return 0; } 时间复杂度：O(N³)\n解法三（费用流解法）：\n核心思想：将\u0026quot;两条路径取最大值\u0026quot;转化为网络流问题。\n建模思路 关键观察： 两条从 A 到 B 的路径 = 从源点到汇点流量为 2 的流 每个格子最多取一次 = 每个节点容量为 1 取得数字最大 = 费用最大（转为最小费用取负值）\n拆点： 每个格子 (i,j) 拆成两个节点 in 和 out： in → out：容量 1，费用 -map[i][j]（取负是因为求最小费用） in → out：再加一条容量 1，费用 0（允许第二条路径经过但不重复取值） 即：合并为容量 2，但只有第一单位流有收益\n连边： (i,j) 的 out 连向 (i+1,j) 的 in 和 (i,j+1) 的 in，容量 2，费用 0。\n源汇： 源点 S 连 (1,1).in，(N,N).out 连汇点 T，流量均为 2。\n每个格子(i,j)拆点后:\n1 2 3 容量1，费用-val (第一条路经过，取走数字) in(i,j) ================\u0026gt; out(i,j) 容量1，费用0 (第二条路经过，数字已取走) 完整代码（MCMF，SPFA实现）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAXN 1000 #define MAXE 10000 #define INF 0x3f3f3f3f // ========== 链式前向星数据结构 ========== int head[MAXN], nxt[MAXE], to[MAXE], cap[MAXE], cost[MAXE], tot; void init() { memset(head, -1, sizeof(head)); tot = 0; } void add_edge(int u, int v, int c, int w) { to[tot] = v; cap[tot] = c; cost[tot] = w; nxt[tot] = head[u]; head[u] = tot++; to[tot] = u; cap[tot] = 0; cost[tot] = -w; nxt[tot] = head[v]; head[v] = tot++; } int dist[MAXN], in_queue[MAXN], prevv[MAXN], preve[MAXN]; int queue[MAXN * 100]; // ========== SPFA算法 ========== int spfa(int s, int t, int n) { memset(dist, 0x3f, sizeof(int) * (n + 1)); memset(in_queue, 0, sizeof(int) * (n + 1)); dist[s] = 0; int front = 0, rear = 0; queue[rear++] = s; in_queue[s] = 1; // SPFA主循环 while (front != rear) { int u = queue[front++]; in_queue[u] = 0; // 松弛边 for (int e = head[u]; e != -1; e = nxt[e]) { if (cap[e] \u0026gt; 0 \u0026amp;\u0026amp; dist[to[e]] \u0026gt; dist[u] + cost[e]) { dist[to[e]] = dist[u] + cost[e]; prevv[to[e]] = u; preve[to[e]] = e; if (!in_queue[to[e]]) { queue[rear++] = to[e]; in_queue[to[e]] = 1; } } } } return dist[t] \u0026lt; INF; } // ========== 最小费用最大流 ========== int mcmf(int s, int t, int n) { int total_cost = 0; while (spfa(s, t, n)) { int flow = INF; for (int v = t; v != s; v = prevv[v]) if (cap[preve[v]] \u0026lt; flow) flow = cap[preve[v]]; for (int v = t; v != s; v = prevv[v]) { cap[preve[v]] -= flow; cap[preve[v] ^ 1] += flow; } total_cost += dist[t] * flow; } return total_cost; } int main() { int N; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); int map[10][10] = {0}; int x, y, v; while (scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;v) \u0026amp;\u0026amp; (x || y || v)) map[x][y] = v; init(); int S = 2 * N * N + 1; int T = 2 * N * N + 2; int total_nodes = T; #define IN(i,j) ((i-1)*N+(j)) #define OUT(i,j) (N*N+(i-1)*N+(j)) for (int i = 1; i \u0026lt;= N; i++) { for (int j = 1; j \u0026lt;= N; j++) { if (map[i][j] \u0026gt; 0) { add_edge(IN(i,j), OUT(i,j), 1, -map[i][j]); add_edge(IN(i,j), OUT(i,j), 1, 0); } else { add_edge(IN(i,j), OUT(i,j), 2, 0); } if (j + 1 \u0026lt;= N) add_edge(OUT(i,j), IN(i,j+1), 2, 0); if (i + 1 \u0026lt;= N) add_edge(OUT(i,j), IN(i+1,j), 2, 0); } } add_edge(S, IN(1,1), 2, 0); add_edge(OUT(N,N), T, 2, 0); int ans = -mcmf(S, T, total_nodes); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } 优势：可轻松扩展到 K 条路径。\n","date":"2026-02-28T11:31:00+08:00","permalink":"https://w2343419-del.github.io/WangScape/p/p1004-noip-2000-%E6%8F%90%E9%AB%98%E7%BB%84-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0-%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/","title":"P1004 [NOIP 2000 提高组] 方格取数 分析与总结"},{"content":"经过了近一天的半天自我怀疑、半天与 AI 搏斗（doge）和全天用头与桌子比硬度\u0026hellip;\u0026hellip;\n2026 年 1 月 21 日最终成为了一个对我而言非同寻常的日子。\n我的个人博客终于上线了！！！\n博客的目标 我将在这里记录：\n编程中遇到的困难、收获和知识点总结 学习心得和算法分析 偶尔的牢骚和书评 喜欢的诗词和其他文化内容 也许这个博客还会成为我的全学科笔记？（至少在大学期间）\n除了代码方面，也许还会涉及人工智能、游戏、音乐、电影等多个领域。我会尽力让博客以学习为主。\n写在末尾 虽然我不知道能否一直维护这个博客（毕竟有点懒），但会尽力而为。\n希望我的更新频率不会太低\u0026hellip;\u0026hellip;\n（ps. 现在的博客还比较粗糙，但以后会更好的！）\n编辑于 2026 年 2 月 3 日\n编辑于2026年2月3日\n","date":"2026-02-03T13:28:00+08:00","permalink":"https://w2343419-del.github.io/WangScape/p/%E4%BD%A0%E5%A5%BD%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/","title":"你好，欢迎来到我的博客"},{"content":"在最近的开发迭代中，对网站进行了多项功能修复和功能扩展，以下是主要的改动列表。\n界面与显示问题修复 修复了左下栏动画卡顿问题 修复了中英文界面的切换问题 修复了头像显示问题 功能扩展与优化 修复了计数功能的问题，解决了 Umami API 的调用问题 推出了网站文章写作推送助手 WSwriter，满足在类 Office 界面进行写作的需求 支持一键预览、提交、修改、删除文章 支持插入代码、图片与表格 用户互动功能 添加了评论功能 修复了 WSwriter 添加标签时出现的双引号错误 安全性维护 对网站安全性进行了全面维护 ","date":"2026-02-02T12:14:00+08:00","permalink":"https://w2343419-del.github.io/WangScape/p/%E7%BD%91%E7%AB%99%E4%BF%AE%E5%A4%8D%E6%80%BB%E7%BB%93/","title":"网站修复总结"}]