# 代码块格式规范指南

## 目的
为文章中的代码块建立统一的格式标准，提高可读性并便于维护。

## 核心原则

### 1. 注释规范
- ✅ **保留**：解释性注释和算法说明
  - 变量含义：`int dp[20][10][10]; // dp[步数][人1的行][人2的行]`
  - 初始化说明：`// 初始化为-1表示不可达`
  - 算法步骤：`// 动态规划主循环`
  - 关键操作：`// 规范化：保证 a <= b`
  - 条件检查：`// SPFA主循环`、`// 松弛边`

- ❌ **删除**：美化性分隔符和冗余分隔
  - 不使用：`// ========== xxx ==========`
  - 不使用：`// ----------- xxx -----------`
  - 不使用：多余的空白分隔符注释

### 2. 缩进和空白
- 使用4个空格作为一个缩进级别
- 函数体内，相关逻辑块之间可用单行空白分隔
- 不过度空白化：避免过多的空行

示例（正确）：
```c
for (int k = 2; k < 2 * N; k++) {
    for (int x1 = 1; x1 <= N; x1++) {
        // 逻辑1
        // ...

        // 逻辑2
        for (int m1 = 0; m1 <= 1; m1++) {
            // 内层逻辑
        }
    }
}
```

### 3. 代码布局
- 单个语句避免过长，超过80字符考虑换行
- 相关声明和操作保持相邻
- 逻辑块之前添加简短的解释注释

示例（正确）：
```c
// 计算当前步收益
int gain = map[nx1][ny1];
if (nx1 != nx2) gain += map[nx2][ny2];

// 规范化：保证 a <= b
int a = nx1, b = nx2;
if (a > b) { int t = a; a = b; b = t; }
```

不好的做法（避免）：
```c
int gain = map[nx1][ny1]; if (nx1 != nx2) gain += map[nx2][ny2]; int a = nx1, b = nx2; if (a > b) { int t = a; a = b; b = t; }
```

## 特定语言的格式

### C/C++
- 使用 ```c 标记代码块
- 保持 K&R 风格或 GNU 风格的缩进一致
- 关键的算法步骤前加注释说明

### Python
- 使用 ```python 标记代码块
- 遵循 PEP 8 规范
- 保留 docstring 和关键逻辑的注释

### Go
- 使用 ```go 标记代码块
- 保留 godoc 风格的注释
- 保留关键调用的说明

## 何时删除内容
1. 分隔符注释（如 `====`、`----` 等）
2. 冗余或自解释的注释（如 `counter++  // 增加计数器`）
3. 已废弃的代码或测试代码
4. 过多的空行（仅保留必要的逻辑分隔）

## 何时保留/添加注释
1. 算法名称或步骤说明
2. 非直观的变量含义
3. 重要的初始化或边界条件
4. 核心算法逻辑的关键操作
5. 数据结构的字段解释

## 示例对比

### ❌ 不推荐
```c
// ========== 数据结构 ==========
int head[MAXN], nxt[MAXE], to[MAXE], cap[MAXE], cost[MAXE];

void init() {
    // 初始化头指针
    memset(head, -1, sizeof(head));
    // 清零边数
    tot = 0;
}

// ========== 核心算法 ==========
int dfs(...) {
    // 递归调用  <- 这是冗余的
    return solve(...);
}
```

### ✅ 推荐
```c
int head[MAXN], nxt[MAXE], to[MAXE], cap[MAXE], cost[MAXE], tot;

void init() {
    memset(head, -1, sizeof(head));
    tot = 0;
}

int dfs(int k, int x1, int x2) {
    // 边界条件：到达目标
    if (x1 == N && x2 == N) return 0;

    // 使用记忆化避免重复计算
    if (visited[k][x1][x2]) return memo[k][x1][x2];
    visited[k][x1][x2] = 1;

    // 递归求解子问题
    int best = dfs(k + 1, ...);
    memo[k][x1][x2] = best;
    return best;
}
```

## 使用清单

写文章时的代码块检查清单：

- [ ] 使用正确的语言标记（```c, ```python 等）
- [ ] 移除所有分隔符注释
- [ ] 保留算法解释和变量含义注释
- [ ] 缩进统一为4个空格
- [ ] 逻辑块之间用单行空白分隔
- [ ] 不超过80字符的单行长度（如可能）
- [ ] 关键操作前有简短说明

## 维护说明

当提交包含代码的文章时，确保代码块符合本规范。如果有特殊情况需要偏离规范，请在注释中说明原因。
